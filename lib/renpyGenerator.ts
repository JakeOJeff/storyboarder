import { Edge } from '@xyflow/react';
import { StoryNode } from './store';

/**
 * Converts Story Nodes and Edges into a Ren'Py script (.rpy).
 */
export function generateRenpyCode(nodes: StoryNode[], edges: Edge[]): string {
    let script = `# Ren'Py script generated by Storyboarder\n\n`;

    // Map node IDs to safe label names
    const labelMap: Record<string, string> = {};
    nodes.forEach((node, index) => {
        // Use node title or ID, sanitized for Ren'Py
        const safeTitle = (node.data.title || node.id)
            .replace(/[^a-zA-Z0-9_]/g, '_')
            .toLowerCase();

        // Ensure "start" node is labeled as "start" for Ren'Py entry point
        if (node.id === 'start') {
            labelMap[node.id] = 'start';
        } else {
            labelMap[node.id] = `scene_${safeTitle}_${index}`;
        }
    });

    nodes.forEach((node) => {
        const data = node.data;
        const currentLabel = labelMap[node.id];
        const outgoingEdges = edges.filter((e) => e.source === node.id);

        script += `label ${currentLabel}:\n`;

        // 1. Visuals - Background
        if (data.visuals.background) {
            // Ren'Py usually expects defined images, but we can't know definitions here.
            // We'll use the filename as a tag or a "scene bg" comment.
            const bgFilename = data.visuals.background.split('/').pop()?.split('.')[0] || 'background';
            script += `    scene bg ${bgFilename} # Path: ${data.visuals.background}\n`;
        }

        // 2. Visuals - Characters
        if (data.visuals.characters && data.visuals.characters.length > 0) {
            data.visuals.characters.forEach((char) => {
                script += `    show ${char}\n`;
            });
        }

        // 3. Audio
        if (data.audio.bgm) {
            script += `    play music "${data.audio.bgm}"\n`;
        }
        if (data.audio.sfx) {
            script += `    play sound "${data.audio.sfx}"\n`;
        }

        // 4. Dialogue
        if (data.dialogue && data.dialogue.length > 0) {
            data.dialogue.forEach((d) => {
                const speaker = d.speaker ? `"${d.speaker.replace(/"/g, '\\"')}"` : '';
                const text = `"${d.text.replace(/"/g, '\\"')}"`;

                if (speaker) {
                    script += `    ${speaker} ${text}\n`;
                } else {
                    script += `    ${text}\n`;
                }

                if (d.animation) {
                    script += `    # Animation: ${d.animation}\n`;
                }
            });
        } else {
            script += `    # No dialogue defined for this scene\n`;
        }

        // 5. Python Logic
        if (data.logic.python) {
            script += `    python:\n`;
            const lines = data.logic.python.split('\n');
            lines.forEach((line) => {
                script += `        ${line}\n`;
            });
        }

        // 6. Navigation (Choices or Jump)
        if (data.choices && data.choices.length > 0) {
            script += `    menu:\n`;
            data.choices.forEach((choice) => {
                const connectedEdge = outgoingEdges.find(e => e.sourceHandle === choice.id);
                const targetLabel = connectedEdge ? labelMap[connectedEdge.target] : null;

                script += `        "${choice.text.replace(/"/g, '\\"') || '...'}":\n`;
                if (targetLabel) {
                    script += `            jump ${targetLabel}\n`;
                } else {
                    script += `            return # End of story\n`;
                }
            });
        } else {
            // Default transition
            const defaultEdge = outgoingEdges[0];
            if (defaultEdge) {
                const targetLabel = labelMap[defaultEdge.target];
                script += `    jump ${targetLabel}\n`;
            } else {
                script += `    return # End of story\n`;
            }
        }

        script += `\n`;
    });

    return script;
}
